open Stdune

let print =
  In_expect_test.printf "%s\n"

module Directory_rules = struct
  type element =
    | File of string
    | Thunk of (unit -> t)
  and
    t = element Appendable_list.t

  let empty = Appendable_list.empty
  let union = Appendable_list.(@)
  let concat t = List.fold_left t ~init:empty ~f:union
  let thunk f = Appendable_list.singleton (Thunk f)
  let file f = Appendable_list.singleton (File f)

  let rec force l =
    List.concat_map (Appendable_list.to_list l) ~f:(function
      | File t -> [t]
      | Thunk f ->
        force (f ()))
end

module Scheme = struct
  include Dune.Scheme.Gen.For_tests
  include Dune.Scheme.Make(Directory_rules)
end

module Dir_set = Dune.Dir_set

module Path = struct
  include Path.Build

  let of_string str = L.relative root (
    match String.split str ~on:'/' with
    | [""] -> []
    | ["."] -> []
    | other -> other)
end

[%%ignore]

let record_calls scheme ~f =
  let calls = ref [] in
  let scheme =
    Scheme.instrument ~print:(fun s -> calls := s :: !calls) scheme
  in
  let res = f scheme in
  (Directory_rules.force res, !calls)

let print_rules scheme ~dir =
  let res1, calls1 =
    record_calls scheme ~f:(Scheme.For_tests.collect_rules_simple ~dir)
  in
  let res2, calls2 =
    record_calls scheme ~f:(fun scheme ->
      Scheme.get_rules (Scheme.evaluate scheme) ~dir)
  in
  if not ((res1 : string list) = res2)
  then
    Exn.code_error
      "Naive [collect_rules_simple] gives result inconsistent with [Scheme.evaluate]"
      [
        "res1", Sexp.List (List.map res1 ~f:(fun s -> Sexp.Atom s));
        "res2", Sexp.List (List.map res2 ~f:(fun s -> Sexp.Atom s));
      ]
  else
    (
      let print_log log =
        let log = match log with | [] -> ["<none>"] | x -> x in
        List.iter log ~f:(fun s -> print ("    " ^ s))
      in
      (if not ((calls1 : string list) = calls2) then (
         print "inconsistent laziness behavior:";
         print "naive calls:";
         print_log calls1;
         print "[evalulate] calls:";
         print_log calls2;)
       else (
         print "calls:";
         print_log calls1
       )
      );
      print "rules:";
      print_log res1)
[%%ignore]

let () =
  let scheme =
    Dune.Scheme.Thunk (fun () -> Empty)
  in
  print_rules scheme ~dir:(Path.of_string "foo/bar")

[%%expect{|
calls:
    thunk
rules:
    <none>
|}]

let scheme_all_but_foo_bar =
  Dune.Scheme.Approximation (
    Dir_set.negate (Dir_set.of_list [Subtree (Path.of_string "foo/bar")]),
    Thunk (fun () -> Empty))

[%%ignore]

let () =
  print_rules scheme_all_but_foo_bar ~dir:(Path.of_string "unrelated/dir")

[%%expect{|
calls:
    t:thunk
rules:
    <none>
|}]

let () =
  print_rules scheme_all_but_foo_bar ~dir:(Path.of_string "foo/bar")

[%%expect{|
inconsistent laziness behavior:
naive calls:
    <none>
[evalulate] calls:
    t:thunk
rules:
    <none>
|}]

let () =
  print_rules scheme_all_but_foo_bar ~dir:(Path.of_string "foo/bar/baz")

[%%expect{|
inconsistent laziness behavior:
naive calls:
    <none>
[evalulate] calls:
    t:thunk
rules:
    <none>
|}]
